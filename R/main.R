# MIT License
#
# Copyright (c) 2023 Ivan Specht
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

#' Run Outbreak Reconstruction
#'
#' This function runs the outbreak reconstruction algo.
#'
#' @param init Initial config generated by initialize().
#' @param noisy Whether to plot the current state of the Markov Chain at each iteration, as well as print the current log-likelihood, substitution rate, and mutation rate.
#' @return The MCMC output.
#' @export
run_mcmc <- function(init, noisy = F, logging = F){
  mcmc <- init[[1]]
  data <- init[[2]]

  output <- list()
  liks <- c()

  #data$n_global = 1

  for (r in 1:data$n_global) {

    # For reproducible results
    #set.seed(r)

    # Make global moves
    mcmc <- global_mcmc(mcmc, data)

    # Chop up the tree into pieces
    if(r == 1){
      roots <- 1
    }
    breakdowns <- breakdown(mcmc, data, old_roots = roots)
    mcmcs <- breakdowns[[1]]
    datas <- breakdowns[[2]]
    roots <- breakdowns[[3]]

    if(noisy){
      message(paste("Parallelizing over", length(mcmcs), "cores..."))
    }

    all_res <- parallel::mclapply(
      1:length(mcmcs),
      function(i, mcmcs, datas){
        local_mcmc(mcmcs[[i]], datas[[i]])
      },
      mcmcs = mcmcs,
      datas = datas,
      mc.set.seed = F,
      mc.cores = length(mcmcs)
    )
    #...or run in series
    # all_res <- list()
    # for (j in 1:length(mcmcs)) {
    #   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
    # }

    # Amalgamate results of parallel MCMC run
    amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)

    # Record amalgamated results, filtering to parameters of interest
    for (i in 1:length(amalgam)) {
      output <- c(output, list(
        amalgam[[i]][data$record]
      ))
    }

    # "mcmc" is now the most recent result
    mcmc <- amalgam[[length(amalgam)]]

    #print(r)

    liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)


    if(noisy){
      message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
      print(plot_network(list(mcmc, data)))
      #print(mcmc$w)
       print(
         paste0(
           "Mutation rate: ",
           signif(mcmc$mu, digits = 4),
           " substitutions/site/day, ",
           signif(mcmc$p, digits = 4),
           " mutations/site/cycle"
         )
       )
       #print(mcmc$pi)
       #print(mcmc$R)
    }

    if(logging){
      write.csv(
        c(
          mcmc$n,
          data$n_obs,
          mcmc$mu,
          mcmc$p,
          mcmc$b,
          mcmc$h,
          mcmc$t,
          mcmc$w
        ),
        quote = F,
        row.names = F,
        file = "log.csv"
      )
    }

    print(mcmc$pi)
    # print(all(sapply(2:mcmc$n, g_lik, mcmc=mcmc, data=data) == mcmc$g_lik[2:mcmc$n]))
    #
    # print(sum(sapply(2:data$n_obs, cc_from_root, mcmc=mcmc)))
    #
    print(mcmc$R)
    #
    # print(length(unlist(mcmc$seq)))
    # print(mcmc$b)
    print(mean(data$s[2:data$n_obs] - sapply(mcmc$seq[2:data$n_obs], function(v){v[1]})))
    print(length(unlist(mcmc$seq)))


  }
  return(list(
    liks, output, data$names, data$rooted
  ))
}



# MIT License
#
# Copyright (c) 2023 Ivan Specht
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

#' Run Outbreak Reconstruction
#'
#' This function runs the outbreak reconstruction algo.
#'
#' @param init Initial config generated by initialize().
#' @param noisy Whether to plot the current state of the Markov Chain at each iteration, as well as print the current log-likelihood, substitution rate, and mutation rate.
#' @return The MCMC output.
#' @export
run_mcmc <- function(init, noisy = F, plotting = F, logging = F){
  mcmc <- init[[1]]
  data <- init[[2]]

  output <- list()
  liks <- c()

  #data$n_global = 1

  for (r in 1:data$n_global) {

    # For reproducible results
    #set.seed(r)

    # Make global moves
    mcmc <- global_mcmc(mcmc, data)

    # Chop up the tree into pieces
    if(r == 1){
      roots <- 1
    }
    #print(roots)
    breakdowns <- breakdown(mcmc, data, old_roots = roots)
    mcmcs <- breakdowns[[1]]
    datas <- breakdowns[[2]]
    #print(breakdowns[[3]])

    if(noisy & length(mcmcs) > 1){
      message(paste("Parallelizing over", length(mcmcs), "cores..."))
    }

    # Parallelize or not
    if(length(mcmcs) > 1){
      ## Foolproof parallelization: write each element of mcmcs to its own .RData file, then run in parallel
      dir.create("tmp")

      for (j in 1:length(mcmcs)) {
        m0 <- mcmcs[[j]]
        d0 <- datas[[j]]
        save(m0, file = paste0("tmp/mcmcs_", j, ".RData"))
        save(d0, file = paste0("tmp/datas_", j, ".RData"))
      }

      # Command to run all these in parallel
      cmd <- paste("Rscript", system.file("local_mcmc_script.R", package = "juniper0"), 1:length(mcmcs))
      cmd <- paste(cmd, collapse = " & ")
      cmd <- paste(cmd, "& wait")

      # Run in parallel
      system(cmd, wait = T)

      # Collect results
      all_res <- list()
      for (j in 1:length(mcmcs)) {
        load(paste0("tmp/res_", j, ".RData"))
        all_res[[j]] <- res
      }

      # Delete the temporary directory
      unlink("tmp", recursive=TRUE)

      # ...or run using parallel package in R...
      # all_res <- parallel::mclapply(
      #   1:length(mcmcs),
      #   function(i, mcmcs, datas){
      #     local_mcmc(mcmcs[[i]], datas[[i]])
      #   },
      #   mcmcs = mcmcs,
      #   datas = datas,
      #   mc.set.seed = F,
      #   mc.cores = length(mcmcs)
      # )

    }else{

      #...or run in series

      all_res <- list()
      for (j in 1:length(mcmcs)) {
        all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
      }
    }


    # Amalgamate results of parallel MCMC run
    amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
    roots <- amalgam[[2]]
    amalgam <- amalgam[[1]]

    # Record amalgamated results, filtering to parameters of interest
    for (i in 1:length(amalgam)) {
      output <- c(output, list(
        amalgam[[i]][data$record]
      ))
    }

    # "mcmc" is now the most recent result
    mcmc <- amalgam[[length(amalgam)]]

    #print(r)

    liks <- c(liks, sum(mcmc$e_lik) + sum(mcmc$g_lik) + sum(mcmc$m_lik) + mcmc$prior)

    ## Safety mode: check dropout
    ## Check that no SNVs are listed in "dropout"
    # for (i in 1:mcmc$n) {
    #   if(any(
    #     mcmc$subs$pos[[i]] %in% mcmc$dropout[[i]]
    #   )){
    #     stop("No mutations should be listed at positions that drop out")
    #   }
    # }

    #print(mcmc$dropout)

    if(plotting){
      print(plot_network(list(mcmc, data)))
    }

    if(noisy){
      message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))

      #print(mcmc$w)
       print(
         paste0(
           "Evolution rate: ",
           signif(mcmc$mu, digits = 4),
           " substitutions/site/day"
         )
       )
       print(
         paste0(
           "Within-host effective population size: exp(",
           signif(mcmc$N_eff, digits = 4),
           " * t) virions after t days"
         )
       )
       print(
         paste0(
           "Sampling rate: ",
           signif(mcmc$pi, digits = 4)
         )
       )
       print(
         paste0(
           "Reproductive number: ",
           signif(mcmc$R, digits = 4)
         )
       )
       print(
         paste0(
           "Total evolutionary time: ",
           signif(tot_evo_time(mcmc, data) / data$n_bases, digits = 4),
           " days"
         )
       )
       print(
         paste0(
           "Total number of mutations: ",
           length(unlist(mcmc$tmu))
         )
       )
       print(
         paste0(
           "Number of included hosts: ",
           length(unlist(mcmc$seq))
         )
       )
       if(!data$rooted){
         print(
           paste0(
             "Epidemic start date: ",
             data$s_max + mcmc$seq[[1]]
           )
         )
       }
    }

    if(logging){
      write.csv(
        c(
          mcmc$n,
          data$n_obs,
          mcmc$mu,
          mcmc$p,
          mcmc$b,
          mcmc$h,
          mcmc$t,
          mcmc$w
        ),
        quote = F,
        row.names = F,
        file = "log.csv"
      )
    }
  }



  return(list(
    liks, output, data$names, data$rooted, data$s_max
  ))
}
